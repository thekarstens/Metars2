<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Apr 2018 Case Study – METAR + Wind Arrows + Daily Particles + Alerts</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Local Leaflet in your repo -->
<link rel="stylesheet" href="./leaflet.css"/>
<script src="./leaflet.js"></script>

<!-- Leaflet Velocity (WORKING CDN) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.css"/>
<script src="https://unpkg.com/leaflet-velocity@2.1.4/dist/leaflet-velocity.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { height:100%; background:#fff; }

  .panel{
    position:absolute; top:10px; left:10px; z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc; border-radius:12px;
    padding:10px;
    font:600 12px/1.2 Arial, sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    min-width: 330px;
  }
  .row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .btn{
    border:1px solid #333; background:#fff; border-radius:10px;
    padding:6px 10px; cursor:pointer; font:700 12px Arial;
  }
  .btn:active{ transform: translateY(1px); }
  .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:800; }

  .dot{
    border-radius:50%;
    border:2px solid #333;
    display:flex;align-items:center;justify-content:center;
    font:800 12px/1 Arial, sans-serif;color:#111;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    user-select:none;
  }

  .swatch {
    display:inline-block;
    width:12px; height:12px;
    border:1px solid #333;
    border-radius:2px;
    vertical-align:middle;
    margin-right:6px;
  }

  .tiny {
    font:600 11px/1.2 Arial, sans-serif;
    opacity:.78;
  }

  /* TV-style banner + dynamic legend */
  .tvbanner{
    position:absolute;
    top:0; left:0; right:0;
    z-index:99999;
    background:rgba(11,28,45,0.92);
    color:#fff;
    font:800 18px/1.2 Arial, sans-serif;
    letter-spacing:0.5px;
    padding:10px 16px;
    border-bottom:1px solid rgba(255,255,255,0.15);
    display:none;
    text-transform:uppercase;
    pointer-events:none;
  }
  .legend{
    position:absolute;
    left:14px;
    bottom:18px;
    z-index:9999;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc;
    border-radius:12px;
    padding:10px 12px;
    font:700 12px/1.25 Arial, sans-serif;
    min-width:220px;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
    display:none;
  }
  .legend .title{ font-size:12px; margin-bottom:6px; }
  .legend .bar{
    height:10px;
    border-radius:6px;
    border:1px solid #333;
    margin:6px 0 6px 0;
  }
  .legend .ticks{
    display:flex;
    justify-content:space-between;
    font:700 11px/1.2 Arial, sans-serif;
    opacity:0.85;
  }

  /* Branding logo (bottom-right, small) */
  #brandLogo{
    position:absolute;
    bottom:10px;
    right:10px;
    top:auto;
    left:auto;
    z-index:100000;
    width:120px;
    max-width:22vw;
    height:auto;
    display:none;
    opacity:0.95;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,0.25));
    pointer-events:none;
  }



/* Make observed radar a bit less 'dark' */
.obs-radar { filter: brightness(1.15) contrast(1.05); }
</style>
</head>

<body>
<div id="map"></div>
<div id="banner" class="tvbanner"></div>
<div id="legend" class="legend"></div>

<!-- Branding (expects a logo file in the same folder as index.html) -->
<img id="brandLogo" alt="Weather Workshops" />

<div class="panel">
  <div style="font-size:13px;margin-bottom:6px">Apr 2018 Case Study</div>

  <!-- Time controls for METAR + Alerts -->
  <div class="row">
    <button class="btn" id="backBtn">◀ Time</button>
    <div class="mono" id="timeLabel">2018-04-14 15Z</div>
    <button class="btn" id="fwdBtn">Time ▶</button>
  </div>

  <!-- Day controls for PARTICLES ONLY -->
  <div class="row">
    <span class="tiny">Particles day:</span>
    <button class="btn" id="dayBackBtn">◀ Apr 13</button>
    <div class="mono" id="dayLabel">Apr 14</div>
    <button class="btn" id="dayFwdBtn">Apr 15 ▶</button>
  </div>

  <div class="row">
    <span style="opacity:.75">Step:</span>
    <span class="mono">3 hours</span>
    <span style="opacity:.75;margin-left:auto">Zoom:</span>
    <span class="mono" id="zoomLabel">6</span>
  </div>

  <div class="row">
    <span class="tiny" id="status">Loading…</span>
  </div>

  <div class="tiny">
    Wind arrows: direction wind is blowing <b>TO</b> (METAR direction + 180°).
  </div>
</div>

<script>
/* ------------------------------------------------------------
   1) Map
------------------------------------------------------------ */
const map = L.map("map", { zoomControl:true }).setView([44.2, -96.5], 6);

// Clean basemap with blue water
const baseTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
  maxZoom: 20,
  attribution: "© OpenStreetMap contributors © CARTO"
}).addTo(map);

// Labels layer (states/cities) to keep the basemap uncluttered
const labelTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png", {
  maxZoom: 20,
  attribution: ""
}).addTo(map);


// Surface analysis overlay (WPC archive image) as a toggleable layer
// URL pattern seen on WPC archive: /archives/sfc/YYYY/namussfcYYYYMMDDHH.gif
// We clamp to 3-hour increments (00/03/06/...)
let surfaceLayer = null;
const SURFACE_BOUNDS = L.latLngBounds([22.0, -130.0], [55.0, -60.0]);
function surfaceUrl(dt){
  const d = new Date(dt.getTime());
  const hr = d.getUTCHours();
  const hr3 = Math.round(hr / 3) * 3;
  d.setUTCHours((hr3+24)%24, 0, 0, 0);
  // if rounding pushed hour to 24, bump day
  if (hr3 >= 24){
    d.setUTCDate(d.getUTCDate()+1);
    d.setUTCHours(0);
  }
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth()+1).padStart(2,'0');
  const dd = String(d.getUTCDate()).padStart(2,'0');
  const hh = String(d.getUTCHours()).padStart(2,'0');
  return `https://www.wpc.ncep.noaa.gov/archives/sfc/${y}/namussfc${y}${m}${dd}${hh}.gif`;
}
function ensureSurfaceLayer(){
  if (surfaceLayer) return;
  surfaceLayer = L.imageOverlay(surfaceUrl(current), SURFACE_BOUNDS, {opacity:0.85, interactive:false});
}
function updateSurfaceLayer(){
  if (!surfaceLayer) return;
  surfaceLayer.setUrl(surfaceUrl(current));
}


// ------------------------------------------------------------
// ------------------------------------------------------------
// Observed Composite Radar (IEM /usrad/ PNG frames - NO repo uploads needed)
// Uses the world-file numbers you provided to compute exact lat/lon bounds.
// World file values:
//   0.005
//   0.0
//   0.0
//  -0.005
//  -126.0
//   50.0
// ------------------------------------------------------------
const TRANSPARENT_PX = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

// World file constants (assumed: C/F are CENTER of upper-left pixel)
const WLD = { A: 0.005, E: -0.005, C: -126.0, F: 50.0 };

function boundsFromWorldFile(widthPx, heightPx){
  const west  = WLD.C - (WLD.A/2);
  const north = WLD.F - (WLD.E/2); // E is negative
  const east  = west  + (WLD.A * widthPx);
  const south = north + (WLD.E * heightPx);
  return L.latLngBounds([[south, west],[north, east]]);
}

function snapToStepUTC(d, stepMin){
  const t = new Date(d.getTime());
  const m = t.getUTCMinutes();
  const snapped = Math.floor(m / stepMin) * stepMin;
  t.setUTCMinutes(snapped, 0, 0);
  return t;
}


  // ===========================================================================
  // OBSERVED COMPOSITE RADAR (IEM n0q) — LOCAL FILES IN YOUR REPO (3-hour frames)
  //
  // Put files here (recommended):  ./radar_frames/n0q_YYYYMMDDHHMM.png
  // Example: ./radar_frames/n0q_201804141500.png
  //
  // Also supported as fallback:   ./radar_files/...
  //
  // Optional bounds file (recommended): ./radar_frames/radar_bounds.json
  // Accepted formats:
  //   {"south":..,"west":..,"north":..,"east":..}
  //   [[south,west],[north,east]]
  //   {"bounds":[[south,west],[north,east]]}
  // ===========================================================================

  const OBS_RADAR_DIRS = ["radar_frames", "radar_files"]; // try in this order
  const OBS_RADAR_PREFIX = "n0q_";                        // you said you're using n0q
  const OBS_RADAR_EXT = ".png";
  const OBS_RADAR_STEP_MINUTES = 180; // 3 hours

  // If we can load bounds from radar_bounds.json, we will.
  // Otherwise we fall back to the standard IEM "world file" geometry, computing bounds from image size:
  // world file params you pasted: dx=0.005, dy=-0.005, west=-126.0, north=50.0
  const WORLD_DX = 0.005;
  const WORLD_DY = -0.005;
  const WORLD_WEST = -126.0;
  const WORLD_NORTH = 50.0;

  let obsRadarBounds = null;   // Leaflet LatLngBounds once known
  let radarObservedLayer = null;
  let _obsBoundsLoadingPromise = null;

  function pad2(n){ return String(n).padStart(2,"0"); }

  function snapToStepUTC(d, stepMinutes){
    const ms = d.getTime();
    const stepMs = stepMinutes * 60 * 1000;
    return new Date(Math.floor(ms / stepMs) * stepMs);
  }

  function obsRadarFilenameForTime(dUTC){
    // dUTC is a JS Date (we assume UTC time is encoded in it for display)
    const y = dUTC.getUTCFullYear();
    const mo = pad2(dUTC.getUTCMonth()+1);
    const da = pad2(dUTC.getUTCDate());
    const hh = pad2(dUTC.getUTCHours());
    const mm = pad2(dUTC.getUTCMinutes());
    // Your filenames look like: n0q_201804141500.png  (NO underscore before HHMM, NO Z)
    return `${OBS_RADAR_PREFIX}${y}${mo}${da}${hh}${mm}${OBS_RADAR_EXT}`;
  }

  function obsRadarCandidateUrls(d){
    const t = snapToStepUTC(d, OBS_RADAR_STEP_MINUTES);
    const fname = obsRadarFilenameForTime(t);

    // Sometimes folks include underscores / Z — try a few variants just in case.
    const y = t.getUTCFullYear();
    const mo = pad2(t.getUTCMonth()+1);
    const da = pad2(t.getUTCDate());
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const variants = [
      fname,
      `${OBS_RADAR_PREFIX}${y}${mo}${da}_${hh}${mm}${OBS_RADAR_EXT}`,
      `${OBS_RADAR_PREFIX}${y}${mo}${da}${hh}${mm}Z${OBS_RADAR_EXT}`,
      `${OBS_RADAR_PREFIX}${y}${mo}${da}_${hh}${mm}Z${OBS_RADAR_EXT}`,
      // old pattern we used earlier:
      `radar_${y}${mo}${da}_${hh}${mm}Z${OBS_RADAR_EXT}`,
    ];

    const urls = [];
    for (const dir of OBS_RADAR_DIRS){
      for (const v of variants){
        urls.push(`./${dir}/${v}`);
      }
    }
    return urls;
  }

  async function firstExistingUrl(urls){
    for (const url of urls){
      try{
        const r = await fetch(url, { method: "HEAD", cache: "no-store" });
        if (r.ok) return url;
        // Some hosts don't like HEAD; fall back to GET
        if (r.status === 405){
          const r2 = await fetch(url, { method: "GET", cache: "no-store" });
          if (r2.ok) return url;
        }
      }catch(e){
        // ignore
      }
    }
    return null;
  }

  function parseBoundsJson(j){
    if (!j) return null;
    // [[south,west],[north,east]]
    if (Array.isArray(j) && j.length === 2 && Array.isArray(j[0]) && j[0].length === 2){
      return L.latLngBounds(j);
    }
    // {bounds:[[...]]}
    if (j.bounds && Array.isArray(j.bounds)){
      return L.latLngBounds(j.bounds);
    }
    // {south,west,north,east}
    if (typeof j.south === "number" && typeof j.west === "number" && typeof j.north === "number" && typeof j.east === "number"){
      return L.latLngBounds([[j.south, j.west],[j.north, j.east]]);
    }
    return null;
  }

  async function loadObsRadarBounds(){
    if (obsRadarBounds) return obsRadarBounds;
    if (_obsBoundsLoadingPromise) return _obsBoundsLoadingPromise;

    _obsBoundsLoadingPromise = (async ()=>{
      // Try bounds file in each folder
      for (const dir of OBS_RADAR_DIRS){
        const url = `./${dir}/radar_bounds.json`;
        try{
          const r = await fetch(url, { cache: "no-store" });
          if (r.ok){
            const j = await r.json();
            const b = parseBoundsJson(j);
            if (b){
              obsRadarBounds = b;
              return obsRadarBounds;
            }
          }
        }catch(e){ /* ignore */ }
      }
      return null;
    })();

    return _obsBoundsLoadingPromise;
  }

  async function computeBoundsFromImage(url){
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload = ()=>{
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;

        const west = WORLD_WEST;
        const north = WORLD_NORTH;
        const east = west + WORLD_DX * w;
        const south = north + WORLD_DY * h; // WORLD_DY is negative
        resolve(L.latLngBounds([[south, west], [north, east]]));
      };
      img.onerror = ()=> resolve(null);
      img.src = url;
    });
  }

  async function ensureObservedRadarLayer(){
    if (radarObservedLayer) return radarObservedLayer;

    // Try to establish bounds
    obsRadarBounds = await loadObsRadarBounds();

    // Create a placeholder layer; we will update URL immediately after
    const dummyBounds = obsRadarBounds || L.latLngBounds([[23.0, -126.0],[50.0, -66.0]]);
    radarObservedLayer = L.imageOverlay("", dummyBounds, {
      opacity: 0.65,
      className: "obs-radar",
      interactive: false
    });

    // Add to layer control (later, in overlays map)
    return radarObservedLayer;
  }

  async function updateObservedRadar(){
    if (!radarObservedLayer) await ensureObservedRadarLayer();

    const urls = obsRadarCandidateUrls(currentTime);
    const chosen = await firstExistingUrl(urls);

    if (!chosen){
      statusEl.textContent = "Observed radar: no matching file found for this time. Check filenames in /radar_frames/ (or /radar_files/).";
      // Clear overlay image
      try { radarObservedLayer.setUrl(""); } catch(e){}
      return;
    }

    // If we still don't know bounds, compute from the image size
    if (!obsRadarBounds){
      obsRadarBounds = await computeBoundsFromImage(chosen);
      if (obsRadarBounds){
        radarObservedLayer.setBounds(obsRadarBounds);
      }
    }

    radarObservedLayer.setUrl(chosen);
  }





map.attributionControl.setPrefix(false);

const statusEl    = document.getElementById("status");
const timeLabelEl = document.getElementById("timeLabel");
const dayLabelEl  = document.getElementById("dayLabel");
const zoomLabelEl = document.getElementById("zoomLabel");

// Branding logo: tries a few common filenames so you don't have to be perfect.
// Put ONE of these files next to index.html in your repo.
const logoEl = document.getElementById("brandLogo");
const logoCandidates = [
  "./logo.png",
  "./logo.webp",
  "./WeatherWorkshops.png",
  "./WeatherWorkshops.webp",
  "./weatherworkshops.png",
  "./ChatGPT Image Jan 19, 2026, 12_15_30 PM.png" // if you upload with this exact name
];
function tryLoadLogo(i=0){
  if (!logoEl) return;
  if (i >= logoCandidates.length) return;
  const src = logoCandidates[i];
  logoEl.onload = () => { logoEl.style.display = "block"; };
  logoEl.onerror = () => { tryLoadLogo(i+1); };
  logoEl.src = src;
}
tryLoadLogo();

function setStatus(msg){ statusEl.textContent = msg; }

map.on("zoomend", ()=>zoomLabelEl.textContent = String(map.getZoom()));
zoomLabelEl.textContent = String(map.getZoom());
/* ------------------------------------------------------------
   TV banner + Legends
------------------------------------------------------------ */
const bannerEl = document.getElementById("banner");
const legendEl = document.getElementById("legend");

const activeOverlays = new Set();
let lastOverlayName = "";

function showBanner(text){
  if (!text){ bannerEl.style.display = "none"; return; }
  bannerEl.textContent = text;
  bannerEl.style.display = "block";
}
function hideBanner(){ bannerEl.style.display = "none"; }

function showLegend(html){
  if (!html){ legendEl.style.display = "none"; legendEl.innerHTML = ""; return; }
  legendEl.innerHTML = html;
  legendEl.style.display = "block";
}
function hideLegend(){ legendEl.style.display = "none"; legendEl.innerHTML = ""; }

function legendTemp(){
  return `
    <div class="title">Temperature (°F)</div>
    <div class="bar" style="background:linear-gradient(90deg, rgb(170,220,255), rgb(120,190,255), rgb(0,70,200), rgb(0,170,0), rgb(255,235,0), rgb(255,140,0), rgb(255,80,0));"></div>
    <div class="ticks"><span>10</span><span>30</span><span>50</span><span>70+</span></div>
  `;
}
function legendDew(){
  return `
    <div class="title">Dew Point (°F)</div>
    <div class="bar" style="background:linear-gradient(90deg, rgb(90,55,20), rgb(140,95,40), rgb(200,160,110), rgb(190,200,140), rgb(0,170,0), rgb(0,90,0));"></div>
    <div class="ticks"><span>10</span><span>30</span><span>50</span><span>70</span></div>
  `;
}
function legendWind(){
  return `
    <div class="title">Wind (mph)</div>
    <div class="bar" style="background:linear-gradient(90deg, rgb(0,40,160), rgb(0,120,255), rgb(0,210,180), rgb(255,220,0), rgb(255,120,0), rgb(255,80,0));"></div>
    <div class="ticks"><span>0</span><span>20</span><span>35</span><span>50+</span></div>
  `;
}
function legendVis(){
  return `
    <div class="title">Visibility (mi)</div>
    <div class="bar" style="background:linear-gradient(90deg, rgba(255,255,255,1), rgba(255,255,255,0.1));"></div>
    <div class="ticks"><span>0</span><span>2</span><span>5</span><span>10+</span></div>
    <div class="tiny" style="margin-top:6px">More transparent = better visibility.</div>
  `;
}
function legendPressure(){
  return `
    <div class="title">Altimeter Trend (inHg / 3h)</div>
    <div class="ticks"><span style="background:#ffdcdc;border:1px solid #333;border-radius:6px;padding:2px 6px">Falling</span>
    <span style="background:#f0f0f0;border:1px solid #333;border-radius:6px;padding:2px 6px">Steady</span>
    <span style="background:#d7f5d7;border:1px solid #333;border-radius:6px;padding:2px 6px">Rising</span></div>
  `;
}
function legendWx(){
  return `
    <div class="title">Present Weather</div>
    <div class="tiny">Codes from METAR (example: -SN, BLSN, FG). Click stations for details.</div>
  `;
}
function legendAlerts(){
  return `
    <div class="title">Alerts</div>
    <div class="tiny">Colored by hazard type when available. Click polygons for details.</div>
  `;
}
function legendParticles(){
  return `
    <div class="title">Daily Wind Particles</div>
    <div class="tiny">Animated wind field for the selected day.</div>
  `;
}




function legendObsRadar(){
  return `
    <div class="title">Composite Radar (Observed)</div>
    <div class="tiny">IEM US composite PNG frames (archive). Opacity can be adjusted later.</div>
  `;
}

function legendRadar(){
  return `
    <div class="title">Radar (HRRR REFD)</div>
    <div class="row"><span class="swatch" style="background:#000"></span>Light</div>
    <div class="row"><span class="swatch" style="background:#fff"></span>Heavy</div>
    <div class="small">HRRR model reflectivity at the current hour.</div>
  `;
}
function legendPtype(){
  return `
    <div class="title">Precip Type (HRRR REFP)</div>
    <div class="row"><span class="swatch" style="background:#00a000"></span>Rain</div>
    <div class="row"><span class="swatch" style="background:#ff4fd8"></span>Freezing rain / ice</div>
    <div class="row"><span class="swatch" style="background:#3a7bff"></span>Snow</div>
    <div class="small">HRRR precip type layer (colors depend on HRRR palette).</div>
  `;
}

function uiForOverlay(name){
  const n = (name || "").toLowerCase();
  if (n.includes("temperature")) return { banner: "Surface Temperatures", legend: legendTemp() };
  if (n.includes("dew")) return { banner: "Dew Point", legend: legendDew() };
  if (n.includes("wind speed") || n === "wind speed (mph)") return { banner: "Sustained Wind Speed", legend: legendWind() };
  if (n.includes("wind arrows")) return { banner: "Wind Direction (Arrows)", legend: legendWind() };
  if (n.includes("gust")) return { banner: "Wind Gusts", legend: legendWind() };
  if (n.includes("visibility")) return { banner: "Visibility", legend: legendVis() };
  if (n.includes("pressure")) return { banner: "Pressure Trend", legend: legendPressure() };
  if (n.includes("weather codes")) return { banner: "Present Weather", legend: legendWx() };
  if (n.includes("alerts")) return { banner: "Weather Alerts", legend: legendAlerts() };
  if (n.includes("composite radar")) return { banner: "COMPOSITE RADAR (OBS)", legend: legendObsRadar() };
  if (n.includes("radar")) return { banner: "RADAR (HRRR)", legend: legendRadar() };
  if (n.includes("precip type") || n.includes("refp")) return { banner: "PRECIPITATION TYPE (HRRR)", legend: legendPtype() };
  if (n.includes("particles")) return { banner: "Wind Particles", legend: legendParticles() };
  return { banner: name, legend: "" };
}

function refreshUI(){
  if (!activeOverlays.size){
    hideBanner(); hideLegend();
    return;
  }
  // Prefer the most recently toggled overlay
  const name = lastOverlayName || Array.from(activeOverlays).slice(-1)[0];
  const ui = uiForOverlay(name);
  showBanner(ui.banner);
  showLegend(ui.legend);
}


/* ------------------------------------------------------------
   2) Time controls (METAR + Alerts)
------------------------------------------------------------ */
let current = new Date(Date.UTC(2018, 3, 14, 15, 0, 0)); // 2018-04-14 15Z
const stepHours = 3;

function fmtZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D} ${H}Z`;
}
function toISOZ(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}-${M}-${D}T${H}:00:00Z`;
}
function updateTimeLabel(){ timeLabelEl.textContent = fmtZ(current); }
updateTimeLabel();

document.getElementById("backBtn").onclick = async () => {
  current = new Date(current.getTime() - stepHours*3600*1000);
  updateTimeLabel();
  await refreshAll();
};
document.getElementById("fwdBtn").onclick = async () => {
  current = new Date(current.getTime() + stepHours*3600*1000);
  updateTimeLabel();
  await refreshAll();
};

// Surface analysis (simple): opens WPC Surface Analysis Archive.
// (We can later auto-load specific timestamp images once you pick which variant you want.)
/* ------------------------------------------------------------
   3) Day controls (Particles only: Apr 13/14/15)
------------------------------------------------------------ */
let particleDay = 14; // 13, 14, 15
function updateDayLabel(){
  dayLabelEl.textContent = (particleDay === 13) ? "Apr 13" : (particleDay === 15) ? "Apr 15" : "Apr 14";
}
updateDayLabel();

document.getElementById("dayBackBtn").onclick = async () => {
  particleDay = Math.max(13, particleDay - 1);
  updateDayLabel();
  await refreshParticlesIfOn();
};
document.getElementById("dayFwdBtn").onclick = async () => {
  particleDay = Math.min(15, particleDay + 1);
  updateDayLabel();
  await refreshParticlesIfOn();
};

/* ------------------------------------------------------------
   4) Layers
------------------------------------------------------------ */
const tempLayer = L.layerGroup().addTo(map);
const dewLayer  = L.layerGroup();
const windNumLayer = L.layerGroup();
const windArrowLayer = L.layerGroup();
const gustLayer = L.layerGroup();
const visLayer  = L.layerGroup();
const presLayer = L.layerGroup();
const wxLayer   = L.layerGroup();

// Alerts
const alertsLayer = L.geoJSON(null).addTo(map);
// HRRR Radar + Precip Type (Tile layers updated as the timeline changes)
// Uses IEM HRRR TMS naming: hrrr::REFD-F0000-YYYYMMDDHHMI and hrrr::REFP-F0000-YYYYMMDDHHMI citeturn0search1
let hrrrRefdLayer = null;
let hrrrRefpLayer = null;

function fmtInitUTC(d){
  // HRRR init time string YYYYMMDDHH00 (minutes set to 00)
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `${Y}${M}${D}${H}00`;
}

function hrrrUrl(product, initUTC, fmin="0000"){
  const layerName = `hrrr::${product}-F${String(fmin).padStart(4,"0")}-${initUTC}`;
  return `https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/${layerName}/{z}/{x}/{y}.png`;
}

function ensureHRRRLayers(){
  if (!hrrrRefdLayer){
    hrrrRefdLayer = L.tileLayer(hrrrUrl("REFD", fmtInitUTC(current)), { opacity: 0.70, updateWhenIdle:true, updateWhenZooming:false });
    hrrrRefdLayer.on("tileerror", () => {
      // If IEM cache is temporarily down (503), avoid silent failure.
      setStatus("HRRR REFD tiles unavailable (IEM returned an error). Try again in a bit.");
    });
  }
  if (!hrrrRefpLayer){
    hrrrRefpLayer = L.tileLayer(hrrrUrl("REFP", fmtInitUTC(current)), { opacity: 0.70, updateWhenIdle:true, updateWhenZooming:false });
    hrrrRefpLayer.on("tileerror", () => {
      setStatus("HRRR precip type tiles unavailable (IEM returned an error). Try again in a bit.");
    });
  }
}

function updateHRRRLayers(){
  // Only update if the layer is currently toggled on (saves tile requests)
  ensureHRRRLayers();
  const initUTC = fmtInitUTC(current);
  if (map.hasLayer(hrrrRefdLayer)) hrrrRefdLayer.setUrl(hrrrUrl("REFD", initUTC));
  if (map.hasLayer(hrrrRefpLayer)) hrrrRefpLayer.setUrl(hrrrUrl("REFP", initUTC));
}


// Particles: placeholder for checkbox + actual velocity layer
const particlesToggle = L.layerGroup();
let particlesLayer = null;

const baseLayers = {}; // keep OSM as the only base layer (no base selector in the control)

// IMPORTANT: HRRR tile layers must be constructed BEFORE adding to the layer control.
// Otherwise Leaflet will receive null layers and crash when it tries to call setZIndex().
ensureHRRRLayers();

const overlays = {
  "Temperature (°F)": tempLayer,
  "Dew Point (°F)": dewLayer,
  "Wind Speed (mph)": windNumLayer,
  "Wind Arrows": windArrowLayer,
  "Wind Gusts (mph)": gustLayer,
  "Visibility (mi)": visLayer,
  "Pressure (trend)": presLayer,
  "Weather Codes": wxLayer,
  "Alerts (WWA)": alertsLayer,
  "Surface Analysis (WPC)": (ensureSurfaceLayer(), surfaceLayer),
  "Composite Radar (Observed)": radarObservedLayer,
  "Radar (HRRR REFD)": hrrrRefdLayer,
  "Precip Type (HRRR REFP)": hrrrRefpLayer,
  "Daily wind particles": particlesToggle
};

const layerControl = L.control.layers(
  baseLayers,
  overlays,
  { collapsed:false }
).addTo(map);


// Map Leaflet layers back to their display names for UI banner/legend
const layerNameById = new Map();
Object.entries(overlays).forEach(([name, layer]) => {
  layerNameById.set(L.Util.stamp(layer), name);
});


/* ------------------------------------------------------------
   5) Collision thinning (drop stations if overlapping)
------------------------------------------------------------ */
class CollisionIndex {
  constructor(cellSizePx){
    this.cell = cellSizePx;
    this.grid = new Map();
  }
  _key(cx, cy){ return `${cx},${cy}`; }
  _cellOf(p){ return [Math.floor(p.x / this.cell), Math.floor(p.y / this.cell)]; }
  canPlace(p, minSepPx){
    const [cx, cy] = this._cellOf(p);
    const r2 = minSepPx * minSepPx;
    for (let dx=-1; dx<=1; dx++){
      for (let dy=-1; dy<=1; dy++){
        const key = this._key(cx+dx, cy+dy);
        const arr = this.grid.get(key);
        if (!arr) continue;
        for (const q of arr){
          const ddx = p.x - q.x;
          const ddy = p.y - q.y;
          if ((ddx*ddx + ddy*ddy) < r2) return false;
        }
      }
    }
    const key = this._key(cx, cy);
    if (!this.grid.has(key)) this.grid.set(key, []);
    this.grid.get(key).push({x:p.x, y:p.y});
    return true;
  }
}

function minSepForZoom(z){
  if (z <= 4) return 54;
  if (z === 5) return 46;
  if (z === 6) return 38;
  if (z === 7) return 32;
  return 0; // z >= 8 show all
}
function allowByCollision(index, lat, lon, minSepPx){
  if (minSepPx <= 0) return true;
  const p = map.latLngToLayerPoint([lat, lon]);
  return index.canPlace(p, minSepPx);
}

/* ------------------------------------------------------------
   6) Color ramps
------------------------------------------------------------ */
function piecewiseColor(x, stops){
  if (x == null || !Number.isFinite(x)) return "rgb(255,255,255)";
  if (x <= stops[0].v) return `rgb(${stops[0].c.join(",")})`;
  if (x >= stops[stops.length-1].v) return `rgb(${stops[stops.length-1].c.join(",")})`;
  for (let i=0; i<stops.length-1; i++){
    const a = stops[i], b = stops[i+1];
    if (x >= a.v && x <= b.v){
      const k = (x - a.v) / (b.v - a.v);
      const r = Math.round(a.c[0] + (b.c[0]-a.c[0]) * k);
      const g = Math.round(a.c[1] + (b.c[1]-a.c[1]) * k);
      const bb= Math.round(a.c[2] + (b.c[2]-a.c[2]) * k);
      return `rgb(${r},${g},${bb})`;
    }
  }
  return "rgb(255,255,255)";
}

function tempColorF(t){
  return piecewiseColor(t, [
    {v: 10, c: [170, 220, 255]},
    {v: 20, c: [120, 190, 255]},
    {v: 30, c: [0, 70, 200]},
    {v: 40, c: [0, 170, 0]},
    {v: 50, c: [150, 255, 150]},
    {v: 60, c: [255, 235, 0]},
    {v: 70, c: [255, 140, 0]},
    {v: 85, c: [255, 80, 0]}
  ]);
}

function dewColorF(td){
  return piecewiseColor(td, [
    {v: 10, c: [90, 55, 20]},
    {v: 20, c: [140, 95, 40]},
    {v: 30, c: [200, 160, 110]},
    {v: 50, c: [190, 200, 140]},
    {v: 60, c: [0, 170, 0]},
    {v: 70, c: [0, 90, 0]}
  ]);
}

function windColorMph(spd){
  return piecewiseColor(spd, [
    {v: 0,  c: [0, 40, 160]},
    {v: 10, c: [0, 120, 255]},
    {v: 20, c: [0, 210, 180]},
    {v: 35, c: [255, 220, 0]},
    {v: 50, c: [255, 120, 0]},
    {v: 70, c: [255, 80, 0]}
  ]);
}

function pressureTrendColor(deltaInHg){
  if (deltaInHg == null || !Number.isFinite(deltaInHg)) return "rgb(248,248,248)";
  if (deltaInHg > 0.02)  return "rgb(215,245,215)";
  if (deltaInHg < -0.02) return "rgb(255,220,220)";
  return "rgb(240,240,240)";
}

function visStyle(vis){
  if (vis == null || !Number.isFinite(vis)) {
    return { bg:"rgba(255,255,255,0.65)", border:"#333" };
  }
  const v = Math.max(0, Math.min(10, vis));
  const alpha = 1 - (v / 10);
  const border = (v < 1) ? "#666" : "#333";
  return { bg:`rgba(255,255,255,${alpha.toFixed(3)})`, border };
}

/* ------------------------------------------------------------
   7) Icons
------------------------------------------------------------ */
function dotIcon(txt, fill, size=28, fontSize=12, borderColor="#333"){
  return L.divIcon({
    className:"",
    html:`<div class="dot"
              style="width:${size}px;height:${size}px;
                     background:${fill};
                     border-color:${borderColor};
                     font-size:${fontSize}px;">${txt}</div>`,
    iconSize:[size,size],
    iconAnchor:[size/2,size/2]
  });
}

/* Wind arrow as inline SVG divIcon */
function windArrowIcon(bearingDeg, mph){
  const spd = (mph == null || !Number.isFinite(mph)) ? 0 : mph;
  const color = windColorMph(spd);

  const Lmin = 14, Lmax = 52;
  const len = Math.max(Lmin, Math.min(Lmax, Lmin + spd * 0.65));

  const w = 60, h = 60;
  const cx = w/2, cy = h/2;

  const svg = `
    <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
      <g transform="translate(${cx},${cy})">
        <line x1="0" y1="${len/2}" x2="0" y2="${-len/2}" stroke="${color}" stroke-width="4" stroke-linecap="round"/>
        <polygon points="0,${-len/2-8} -8,${-len/2+6} 8,${-len/2+6}" fill="${color}"/>
      </g>
    </svg>
  `;

  return L.divIcon({
    className:"",
    html:`<div style="width:${w}px;height:${h}px;transform:rotate(${bearingDeg}deg);">
            ${svg}
          </div>`,
    iconSize:[w,h],
    iconAnchor:[w/2,h/2]
  });
}

/* ------------------------------------------------------------
   8) Helpers
------------------------------------------------------------ */
function num(v){
  const s = (v ?? "").toString().trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}
function ktToMph(kt){ return kt == null ? null : (kt * 1.15078); }

function parseVisMiles(raw){
  if (raw == null) return { miles:null, label:"" };
  let s = String(raw).trim();
  if (!s) return { miles:null, label:"" };

  if (s.startsWith("M")) s = s.slice(1);
  s = s.replace(/\s+/g, " ");

  const n = Number(s);
  if (Number.isFinite(n)) return { miles:n, label:formatVisLabel(n) };

  const parts = s.split(" ");
  let whole = 0;
  let frac = null;

  if (parts.length === 2){
    whole = Number(parts[0]);
    frac = parts[1];
  } else {
    frac = parts[0];
  }

  if (frac && frac.includes("/")){
    const [a,b] = frac.split("/").map(Number);
    if (Number.isFinite(a) && Number.isFinite(b) && b !== 0){
      const val = (Number.isFinite(whole) ? whole : 0) + (a/b);
      return { miles:val, label:formatVisLabel(val) };
    }
  }
  return { miles:null, label:String(raw).trim() };
}
function formatVisLabel(x){
  if (!Number.isFinite(x)) return "";
  if (x >= 10) return "10+";

  const denom = 8;
  const whole = Math.floor(x);
  const frac = x - whole;
  const nume = Math.round(frac * denom);

  if (nume === 0) return String(whole);
  if (nume === denom) return String(whole + 1);

  const gcd = (a,b)=>b?gcd(b,a%b):a;
  const g = gcd(nume, denom);
  const n = nume / g;
  const d = denom / g;

  if (whole === 0) return `${n}/${d}`;
  return `${whole} ${n}/${d}`;
}

function popupHTML(r, dAlt){
  const tmp = num(r.tmpf);
  const dew = num(r.dwpf);
  const drct = num(r.drct);
  const sknt = num(r.sknt);
  const gust = num(r.gust);
  const alti = num(r.alti);

  const mph  = sknt != null ? Math.round(ktToMph(sknt)) : "—";
  const gmh  = gust != null ? Math.round(ktToMph(gust)) : "—";
  const altTxt = alti != null ? alti.toFixed(2) : "—";
  const dTxt = (dAlt == null) ? "—" : `${dAlt > 0 ? "+" : ""}${dAlt.toFixed(2)} in/3h`;

  const visObj = parseVisMiles(r.vsby);
  const visTxt = (visObj.label || r.vsby || "—");

  const toDir = (drct != null) ? ((drct + 180) % 360) : null;

  return `
    <div style="font:600 13px/1.3 Arial,sans-serif">
      <div style="font-size:14px;margin-bottom:4px"><b>${r.station || "Station"}</b></div>
      <div style="opacity:.85;margin-bottom:6px">Valid: ${r.valid || ""} UTC</div>
      <div>Temp: <b>${tmp == null ? "—" : Math.round(tmp)}</b> °F</div>
      <div>Dew Pt: <b>${dew == null ? "—" : Math.round(dew)}</b> °F</div>
      <div>Wind: <b>${mph}</b> mph (gust <b>${gmh}</b>)</div>
      <div>Wind dir (FROM): <b>${drct == null ? "—" : drct.toFixed(0)}°</b></div>
      <div>Arrow points (TO): <b>${toDir == null ? "—" : toDir.toFixed(0)}°</b></div>
      <div>Vis: <b>${visTxt}</b> mi</div>
      <div>Altimeter: <b>${altTxt}</b> inHg</div>
      <div>Alt trend (3h): <b>${dTxt}</b></div>
      <div>Wx: <b>${(r.wxcodes || "").trim() || "—"}</b></div>
    </div>
  `;
}

/* ------------------------------------------------------------
   9) METAR fetch
------------------------------------------------------------ */
const reportType = 3;
const SD_ONLY = ["SD_ASOS"];
const REST = ["MN_ASOS","IA_ASOS","NE_ASOS","ND_ASOS","WI_ASOS","KS_ASOS","MO_ASOS"];

function asosURL(d, networks){
  const iso = toISOZ(d);
  return "https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py"
    + "?data=tmpf&data=dwpf&data=drct&data=sknt&data=gust&data=vsby&data=alti&data=wxcodes"
    + `&network=${encodeURIComponent(networks.join(","))}`
    + `&report_type=${reportType}`
    + "&latlon=yes&format=onlycomma&tz=UTC"
    + `&sts=${encodeURIComponent(iso)}`
    + `&ets=${encodeURIComponent(iso)}`
    + "&missing=empty";
}

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() && !l.startsWith("#"));
  if (lines.length < 2) return [];
  const header = lines[0].split(",");
  return lines.slice(1).map(line => {
    const cols = line.split(",");
    const obj = {};
    header.forEach((h,i)=>obj[h]=cols[i] ?? "");
    return obj;
  });
}

async function fetchRows(d, networks){
  const resp = await fetch(asosURL(d, networks), { cache:"no-store" });
  if (!resp.ok) throw new Error(`METAR HTTP ${resp.status}`);
  return parseCSV(await resp.text());
}

/* ------------------------------------------------------------
   10) Alerts styling + LOADER (UPDATED for your new filenames)
------------------------------------------------------------ */
const NWS_EVENT_COLOR = {
  // Common severe/flood colors (simple, TV-friendly)
  "Tornado Warning": "#FF0000",
  "Severe Thunderstorm Warning": "#FFD700",
  "Flash Flood Warning": "#00FF00",
  "Flood Warning": "#00A884",
  "Flood Advisory": "#00B3B3",

  // VTEC shorthand fallbacks (phen.sig)
  "TO.W": "#FF0000",
  "SV.W": "#FFD700",
  "FF.W": "#00FF00",
  "FL.W": "#00A884",
  "FA.Y": "#00B3B3",

  "Blizzard Warning": "#FF4500",
  "Winter Storm Warning": "#FF69B4",
  "Winter Storm Watch": "#4682B4",
  "Winter Weather Advisory": "#7B68EE",
  "Ice Storm Warning": "#8B008B",
  "Snow Squall Warning": "#C71585",
  "High Wind Warning": "#DAA520",
  "Wind Advisory": "#D2B48C",
  "Dense Fog Advisory": "#708090"
};

function pickProp(p, keys){
  if (!p) return "";
  for (const k of keys){
    if (p[k] != null && String(p[k]).trim() !== "") return String(p[k]).trim();
    const kk = Object.keys(p).find(x => x.toLowerCase() === k.toLowerCase());
    if (kk && p[kk] != null && String(p[kk]).trim() !== "") return String(p[kk]).trim();
  }
  return "";
}

function eventNameFromProps(p){
  const e = pickProp(p, ["event","headline","name","title"]);
  if (e) return e;

  const phen = pickProp(p, ["phenomena","phenom","PHENOM","phen"]);
  const sig  = pickProp(p, ["significance","sig","SIG"]);
  if (phen && sig){
    const key = `${phen}.${sig}`.toUpperCase();
    if (key === "TO.W") return "Tornado Warning";
    if (key === "SV.W") return "Severe Thunderstorm Warning";
    if (key === "FF.W") return "Flash Flood Warning";
    if (key === "FL.W") return "Flood Warning";
    if (key === "FA.Y") return "Flood Advisory";
    if (key === "BZ.W") return "Blizzard Warning";
    if (key === "WS.W") return "Winter Storm Warning";
    if (key === "WS.A") return "Winter Storm Watch";
    if (key === "WW.Y") return "Winter Weather Advisory";
    return key;
  }

  const wfo = pickProp(p, ["WFO","wfo"]);
  const etn = pickProp(p, ["ETN","etn"]);
  return (wfo || etn) ? `Alert ${wfo || ""} ${etn || ""}`.trim() : "Alert";
}

function colorForAlertName(name){
  if (NWS_EVENT_COLOR[name]) return NWS_EVENT_COLOR[name];
  const lower = String(name).toLowerCase();
  // Text matches (some feeds don't provide clean 'event')
  if (lower.includes("tornado") && lower.includes("warning")) return NWS_EVENT_COLOR["Tornado Warning"];
  if (lower.includes("severe") && lower.includes("thunderstorm") && lower.includes("warning")) return NWS_EVENT_COLOR["Severe Thunderstorm Warning"];
  if (lower.includes("flash") && lower.includes("flood") && lower.includes("warning")) return NWS_EVENT_COLOR["Flash Flood Warning"];
  if (lower.includes("flood") && lower.includes("warning")) return NWS_EVENT_COLOR["Flood Warning"];
  if (lower.includes("flood") && (lower.includes("advisory") || lower.includes("statement"))) return NWS_EVENT_COLOR["Flood Advisory"];

  if (lower.includes("blizzard") && lower.includes("warning")) return NWS_EVENT_COLOR["Blizzard Warning"];
  if (lower.includes("winter storm") && lower.includes("warning")) return NWS_EVENT_COLOR["Winter Storm Warning"];
  if (lower.includes("winter storm") && lower.includes("watch")) return NWS_EVENT_COLOR["Winter Storm Watch"];
  if (lower.includes("winter weather") && lower.includes("advisory")) return NWS_EVENT_COLOR["Winter Weather Advisory"];
  // Last resort: keep polygons visible, but not everything red
  return "#B000B0";
}

// NEW (your repo): alerts_20180414_0000Z.geojson
function alertsFileCompactHourly(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `./timeline_hourly/alerts_${Y}${M}${D}_${H}00Z.geojson`; // NEW location in repo
}

// OLD (your repo): alerts_2018-04-14T21Z.geojson
function alertsFileOldDash(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `./timeline_hourly/alerts_${Y}-${M}-${D}T${H}Z.geojson`; // legacy naming in timeline_hourly
}

// Extra fallback (sometimes people store T2100Z)
function alertsFileOldWithMinutes(d){
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth()+1).padStart(2,"0");
  const D = String(d.getUTCDate()).padStart(2,"0");
  const H = String(d.getUTCHours()).padStart(2,"0");
  return `./timeline_hourly/alerts_${Y}-${M}-${D}T${H}00Z.geojson`; // legacy naming in timeline_hourly
}

async function fetchFirstOk(urls){
  let lastErr = "";
  for (const u of urls){
    try{
      const r = await fetch(u, { cache:"no-store" });
      if (!r.ok) { lastErr = `HTTP ${r.status}`; continue; }
      const gj = await r.json();
      return { url: u, gj };
    } catch(e){
      lastErr = e.message || String(e);
    }
  }
  throw new Error(lastErr || "No alert file matched");
}

async function loadAlerts(){
  if (!map.hasLayer(alertsLayer)) return;

  // Prefer your new hourly timeline files, but keep backward compatibility
  const candidates = [
    alertsFileCompactHourly(current),
    alertsFileOldDash(current),
    alertsFileOldWithMinutes(current)
  ];

  try{
    const { url, gj } = await fetchFirstOk(candidates);

    alertsLayer.clearLayers();

    L.geoJSON(gj, {
      style: (feat) => {
        const p = feat.properties || {};
        const name = eventNameFromProps(p);
        const c = colorForAlertName(name);
        return { weight:2, color:c, fillColor:c, fillOpacity:0.18 };
      },
      onEachFeature: (feat, layer) => {
        const p = feat.properties || {};
        const name = eventNameFromProps(p);
        const c = colorForAlertName(name);

        const wfo = pickProp(p, ["WFO","wfo"]);
        const etn = pickProp(p, ["ETN","etn"]);
        const status = pickProp(p, ["STATUS","status"]);
        const issued = pickProp(p, ["issuance","issued","onset","ISSUANCE","ISSUED"]);
        const expire = pickProp(p, ["expire","expires","end","EXPIRE","EXPIRES"]);

        const lines = [];
        lines.push(`<div><span class="swatch" style="background:${c}"></span><b>${name}</b></div>`);
        if (wfo || etn) lines.push(`Office/Event: <b>${wfo || "—"}</b> / <b>${etn || "—"}</b>`);
        if (status) lines.push(`Status: <b>${status}</b>`);
        if (issued) lines.push(`Issued: <b>${issued}</b>`);
        if (expire) lines.push(`Expires: <b>${expire}</b>`);

        const hasHazard = !!pickProp(p, ["event","phenomena","phenom","PHENOM","significance","sig","SIG"]);
        if (!hasHazard){
          lines.push(`<div style="margin-top:6px;opacity:.75">
            Note: this alert file doesn’t include hazard type (Blizzard/WSW/etc), so colors may be limited.
          </div>`);
        }

        layer.bindPopup(lines.join("<br>"));
      }
    }).eachLayer(l => alertsLayer.addLayer(l));

    // Small status breadcrumb to confirm which file actually loaded
    setStatus(`Alerts loaded: ${url.replace("./","")}`);

  } catch(e){
    console.warn("Alerts load failed:", e.message);
    alertsLayer.clearLayers();
    setStatus("Alerts not found for this hour (check filenames).");
  }
}

/* ------------------------------------------------------------
   11) Daily particles (toggle + day buttons)
------------------------------------------------------------ */
function particlesFileForDay(dayNum){
  return `./wind_particles_201804${String(dayNum).padStart(2,"0")}.json`;
}

function normalizeVelocityJson(raw){
  if (Array.isArray(raw)) return raw;
  if (raw && Array.isArray(raw.data)) return raw.data;
  return raw;
}

async function refreshParticlesIfOn(){
  if (!map.hasLayer(particlesToggle)) return;

  if (typeof L.velocityLayer !== "function"){
    setStatus("Wind particles: leaflet-velocity did not load.");
    return;
  }

  const url = particlesFileForDay(particleDay);

  try{
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const raw = await r.json();
    const velData = normalizeVelocityJson(raw);

    if (particlesLayer){
      try { map.removeLayer(particlesLayer); } catch(_) {}
      particlesLayer = null;
    }

    particlesLayer = L.velocityLayer({
      data: velData,
      velocityScale: 0.004,
      particleAge: 120,
      particleMultiplier: 1/900,
      lineWidth: 1.7,
      colorScale: [
        "rgb(0,40,160)",
        "rgb(0,120,255)",
        "rgb(0,210,180)",
        "rgb(255,220,0)",
        "rgb(255,120,0)"
      ],
      minVelocity: 0,
      maxVelocity: 60,
      displayValues: false
    });

    particlesLayer.addTo(map);
    setStatus(`Particles loaded: ${url.replace("./","")}`);

  } catch(e){
    console.warn("Particles failed:", url, e.message);
    setStatus(`Particles not found: ${url.replace("./","")}`);
  }
}

/* Toggle handlers for particles + alerts */
map.on("overlayadd", async (e) => {
  const name = layerNameById.get(L.Util.stamp(e.layer)) || "";
  if (name){
    activeOverlays.add(name);
    lastOverlayName = name;
    refreshUI();
  }

  // Existing behaviors
  if (e.layer === particlesToggle) await refreshParticlesIfOn();
  if (e.layer === alertsLayer) await loadAlerts();
  if (e.layer === radarObservedLayer) { updateObservedRadar(); }
  if (e.layer === hrrrRefdLayer || e.layer === hrrrRefpLayer) { updateHRRRLayers();
  updateSurfaceLayer(); }
});

map.on("overlayremove", (e) => {
  const name = layerNameById.get(L.Util.stamp(e.layer)) || "";
  if (name){
    activeOverlays.delete(name);
    // if the removed overlay was the last active one, pick another (if any)
    if (lastOverlayName === name){
      lastOverlayName = Array.from(activeOverlays).slice(-1)[0] || "";
    }
    refreshUI();
  }

  // Existing behavior: remove velocity layer
  if (e.layer === particlesToggle && particlesLayer){
    map.removeLayer(particlesLayer);
    particlesLayer = null;
  }
});

/* ------------------------------------------------------------
   12) Main refresh (METAR + alerts + arrows)
------------------------------------------------------------ */
async function refreshAll(){
  setStatus("Loading METARs…");

  const prev = new Date(current.getTime() - stepHours*3600*1000);

  const [sdNow, restNow, sdPrev, restPrev] = await Promise.all([
    fetchRows(current, SD_ONLY),
    fetchRows(current, REST),
    fetchRows(prev, SD_ONLY),
    fetchRows(prev, REST)
  ]);

  const rowsNow  = sdNow.concat(restNow);
  const rowsPrev = sdPrev.concat(restPrev);

  const prevAlt = new Map();
  for (const r of rowsPrev){
    const st = (r.station || "").trim();
    const a  = num(r.alti);
    if (st && a != null) prevAlt.set(st, a);
  }

  [tempLayer, dewLayer, windNumLayer, windArrowLayer, gustLayer, visLayer, presLayer, wxLayer].forEach(l => l.clearLayers());

  const z = map.getZoom();
  const minSep = minSepForZoom(z);

  const idxTemp = new CollisionIndex(Math.max(24, minSep));
  const idxDew  = new CollisionIndex(Math.max(24, minSep));
  const idxWind = new CollisionIndex(Math.max(24, minSep));
  const idxGust = new CollisionIndex(Math.max(24, minSep));
  const idxVis  = new CollisionIndex(Math.max(24, minSep));
  const idxPres = new CollisionIndex(Math.max(24, minSep));
  const idxWx   = new CollisionIndex(Math.max(24, minSep));
  const idxArr  = new CollisionIndex(Math.max(30, minSep));

  let shown = 0, total = 0;

  for (const r of rowsNow){
    const lat = num(r.lat), lon = num(r.lon);
    if (lat == null || lon == null) continue;
    total++;

    const st = (r.station || "").trim();
    const alti = num(r.alti);
    const prevA = st ? prevAlt.get(st) : null;
    const dAlt = (alti != null && prevA != null) ? (alti - prevA) : null;

    const popup = popupHTML(r, dAlt);

    const tmp = num(r.tmpf);
    const dew = num(r.dwpf);

    const drct = num(r.drct);
    const sknt = num(r.sknt);
    const gust = num(r.gust);

    const mph  = sknt != null ? ktToMph(sknt) : null;
    const gmh  = gust != null ? ktToMph(gust) : null;

    const visObj = parseVisMiles(r.vsby);
    const visMi = visObj.miles;

    if (tmp != null && allowByCollision(idxTemp, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(tmp)), tempColorF(tmp), 28, 12) })
        .bindPopup(popup).addTo(tempLayer);
    }

    if (dew != null && allowByCollision(idxDew, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(dew)), dewColorF(dew), 28, 12) })
        .bindPopup(popup).addTo(dewLayer);
    }

    if (mph != null && allowByCollision(idxWind, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(mph)), windColorMph(mph), 28, 12) })
        .bindPopup(popup).addTo(windNumLayer);
    }

    if (mph != null && drct != null && allowByCollision(idxArr, lat, lon, minSep)){
      const toDir = (drct + 180) % 360;
      L.marker([lat,lon], { icon: windArrowIcon(toDir, mph) })
        .bindPopup(popup).addTo(windArrowLayer);
    }

    if (gmh != null && allowByCollision(idxGust, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(String(Math.round(gmh)), windColorMph(gmh), 30, 12) })
        .bindPopup(popup).addTo(gustLayer);
    }

    if ((visObj.label || "").trim() && allowByCollision(idxVis, lat, lon, minSep)){
      const style = visStyle(visMi);
      L.marker([lat,lon], { icon: dotIcon(visObj.label, style.bg, 30, 11, style.border) })
        .bindPopup(popup).addTo(visLayer);
    }

    if (alti != null && allowByCollision(idxPres, lat, lon, minSep)){
      const fill = pressureTrendColor(dAlt);
      L.marker([lat,lon], { icon: dotIcon(alti.toFixed(2), fill, 44, 12, "#999") })
        .bindPopup(popup).addTo(presLayer);
    }

    const wx = (r.wxcodes || "").trim();
    if (wx && allowByCollision(idxWx, lat, lon, minSep)){
      L.marker([lat,lon], { icon: dotIcon(wx, "rgba(255,255,255,0.85)", 30, 10, "#999") })
        .bindPopup(popup).addTo(wxLayer);
    }

    shown++;
  }

  setStatus(`Stations shown: ${shown}/${total} (minSep ${minSep}px).`);

  updateObservedRadar();

  updateHRRRLayers();
  updateSurfaceLayer();
  await loadAlerts();
}

refreshAll().catch(err => {
  console.error(err);
  setStatus("Error: " + err.message);
});
</script>
</body>
</html>
